""" A collection of metrics to evalaute agents with. """

import numpy as np
from featureExtractor.drone_feature_extractor import dist_2d


def compute_trajectory_smoothness(trajectory):
    """
    Returns the total and per step change in the orientation (in degrees)
    of the agent during the duration of the trajectory
        input : trajectory (a list of states)
        output : total change in orientation,
                 avg change in orientation
    """

    change_in_orientation = 0
    prev_orientation = None
    for state in trajectory:

        if prev_orientation is None:
            prev_orientation = state["agent_head_dir"]

        change_in_orientation += abs(
            prev_orientation - state["agent_head_dir"]
        )
        prev_orientation = state["agent_head_dir"]

    return change_in_orientation, change_in_orientation / len(trajectory)


def compute_distance_displacement_ratio(trajectory, compare_expert=True):
    """
    Returns the ration between the final displacement achieved by the agent and
    the distance travelled by the agent. Meant as an objective
    measure of the goodness of the path taken by the agent
    The value is in the range of [1 - 0], where values close to
    1 indicate that the path taken by the agent are close to
    optimal paths that could have been taken
        input : trajectory
        output : final dispacement/ total distance travelled
    """

    total_displacement = np.linalg.norm(
        trajectory[0]["agent_state"]["position"]
        - trajectory[-1]["agent_state"]["position"]
    )

    total_distance = 0
    prev_pos = trajectory[0]["agent_state"]["position"]
    for state in trajectory[1:]:

        step_distance = np.linalg.norm(
            prev_pos - state["agent_state"]["position"]
        )

        total_distance += step_distance
        prev_pos = state["agent_state"]["position"]

    return total_displacement / total_distance


def proxemic_intrusions(trajectory, units_to_meters_ratio):
    """
    Calculate number of proxemic intrusions as defined by the proxemics model:
    "E. Hall, Handbook of Proxemics Research. Society for the Anthropology of
    Visual Communications, 1974."

    Based on Vasquez et. al's use in their paper:
    "IRL algos and features for robot navigation in crowds"

    This is a similified version ignoring public space and near/far phases,
    using thresholds found at:
    "https://en.wikipedia.org/wiki/Proxemics"

    :param trajectory: Trajectory of states generated by environment.
    :type trajectory: List of state_dicts

    :param units_to_meters_ratio: the ratio (env distance unit length) / (1
    meter). e.g. if 1 env unit is 10 cm, this ratio is 0.1.
    :type units_to_meters_ratio: float.

    :return: Number of intrusions in initimate, personal, and social spaces.
    :return type: tuple (int, int, int)
    """

    # Thresholds
    INTIMIATE_DISTANCE = 0.5 * units_to_meters_ratio
    PERSONAL_DISTANCE = 1.2 * units_to_meters_ratio
    SOCIAL_DISTANCE = 3.7 * units_to_meters_ratio

    # bins
    intimiate_intrusions = 0
    personal_intrusions = 0
    social_intrusions = 0

    for traj in trajectory:
        pedestrians = traj["obstacles"]
        agent_position = traj["agent_state"]["position"]

        for ped in pedestrians:
            ped_position = ped["position"]

            distance = dist_2d(ped_position, agent_position)

            if distance <= INTIMIATE_DISTANCE:
                intimiate_intrusions += 1
            elif INTIMIATE_DISTANCE < distance <= PERSONAL_DISTANCE:
                personal_intrusions += 1
            elif PERSONAL_DISTANCE < distance <= SOCIAL_DISTANCE:
                social_intrusions += 1
            elif distance > SOCIAL_DISTANCE:
                continue
            else:
                raise ValueError("Distance did not fit in any bins.")

    return intimiate_intrusions, personal_intrusions, social_intrusions
